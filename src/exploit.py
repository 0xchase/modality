import angr
import sys
import claripy
from termcolor import colored
import logging

from src.concrete.target import R2ConcreteTarget

class Exploiter():
    def __init__(self):
        pass
    
    def explore(self):
        print("Exploring for vulnerable program state")
        #p = angr.Project("basic", load_options={"auto_load_libs": False})
        p = self.r2angr.project
        simgr = self.r2angr.simgr

        p.hook_symbol("printf", hook_printf())
        p.hook_symbol("__isoc99_scanf", hook_scanf())

        for state in simgr.active:
            state.inspect.b("mem_write", when=angr.BP_AFTER, action=self.breakpoint_mem_write)

        #stdin = claripy.BVS("stdin", 300*8)
        #state = p.factory.entry_state(stdin=stdin);
        #simgr = p.factory.simgr(state, save_unconstrained=True);

        print("Current number of active states is: " + str(len(simgr.active)))
        while len(simgr.active) > 0:
            #print(str(simgr) + " " + str(simgr.active[0].regs.rip))
            simgr.step()

            if len(simgr.unconstrained) > 0:
                print("Found unconstrained state")

                for s in simgr.unconstrained:
                    if self.fully_symbolic(s, s.regs.pc):
                        print("Reached fully symbolic pc")
                        #break

                    # Less zeratool
                    state_copy = s.copy()
                    constraints = []
                    for i in range(int(state_copy.arch.bits/8)):
                        constraints.append(claripy.And(state_copy.regs.pc.get_byte(i) == 0x42))

                    if state_copy.solver.satisfiable(extra_constraints=constraints):
                        print("Can constriant pc to 0x42424242")
                        for constraint in constraints:
                            state_copy.add_constraints(constraint)

                    print("Vulnerable path found")

                    logging.getLogger("claripy.ast.bv").disabled = True

                    skipped = 0
                    count = 0
                    for byte in self.r2angr.stdin.chop(8):
                        if state_copy.solver.satisfiable(extra_constraints=[byte == "\x41"]):
                            state_copy.add_constraints(byte == "A")
                            print(colored("[", "yellow") + colored("R2ANGR", "green") + colored("] ", "yellow") + colored("Constraining stdin bytes. Constrained: ", "yellow") + str(count) + colored(", Skipped: ", "yellow") + str(skipped), end="\r")
                            count += 1
                        else:
                            skipped += 1
                    
                    print(colored("[", "yellow") + colored("R2ANGR", "green") + colored("] ", "yellow") + colored("Constraining stdin bytes. Constrained: ", "yellow") + str(count) + colored(", Skipped: ", "yellow") + str(skipped))

                    logging.getLogger("claripy.ast.bv").disabled = False

                    stdin_shellcode = state_copy.posix.dumps(0)

                    stdin_shellcode = stdin_shellcode[0:stdin_shellcode.rfind(b'\x42')+1]
                    self.print_shellcode(stdin_shellcode)

                    simgr.unconstrained.remove(s)

                simgr.drop(stash="unconstrained")


    def fully_symbolic(self, state, variable):
        for i in range(state.arch.bits):
            if not state.solver.symbolic(variable[i]):
                print("Found non-symbolic bit")
                return False
        return True

    def print_shellcode(self, shellcode):
        shellcode_str = ""
        for byte in shellcode:
            shellcode_str += "\\x" + hex(byte)[2:].zfill(2)#.replace("00", "41").replace("01", "41")

        final = ""
        for byte in shellcode_str.split("\\x"):
            if not byte == "":
                temp = "\\x" + byte
                if "41" in byte:
                    temp = colored(temp, "blue")
                if "42" in byte:
                    temp = colored(temp, "red")

                final += temp

        print(final)
    
    def breakpoint_mem_write(self, state):
        print("Writing " + str(state.inspect.mem_write_expr) + " to location " + str(state.inspect.mem_write_address))

    def print_explore(self):
        self.print_debug(colored("Found " + str(len(self.r2angr.simgr.found)) + " solutions", "green"))
    
    def print_debug(self, s):
        print(colored("[", "yellow") + colored("DEBUG", "blue") + colored("] ", "yellow") + colored(s, "yellow"))

class hook_printf(angr.procedures.libc.printf.printf):
    def run(self):
        print("Hooked printf at " + hex(self.addr))

        return super(type(self), self).run()

class hook_scanf(angr.procedures.libc.scanf.scanf):
    def run(self, fmt):
        print("Hooked scanf at " + hex(self.addr) + " with format string " + str(fmt))
        return super(type(self), self).run(fmt)

